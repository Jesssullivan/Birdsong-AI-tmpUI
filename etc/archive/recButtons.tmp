import React, { Component } from 'react';
import AudioRecorderPlayer from "react-native-audio-recorder-player";
const RNFS = require('react-native-fs');
const toWav = require('audiobuffer-to-wav');
const AudioContext = require('web-audio-api').AudioContext;

import {
  StyleSheet,
  TouchableOpacity,
  Text,
  View,
} from 'react-native';
import {audio_utils, spectrogram_utils} from "../src";

const audioRecorderPlayer = new AudioRecorderPlayer();

const btnStyles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  button: {
    alignItems: 'center',
    backgroundColor: '#DDDDDD',
    padding: 10,
    marginBottom: 10
  }
});

const btnStyles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  button: {
    alignItems: 'center',
    backgroundColor: '#DDDDDD',
    padding: 10,
    marginBottom: 10
  }
});

export class RecButtons extends Component {

  RecMsg = 'Tap to begin recording';
  PSMsg = 'Play/Stop';
  complete: void | undefined;

  state = {
    recIsPressed: true,
    playStopIsPressed: true
  };

  onRecPress = async () => {

    this.setState({
      recIsPressed: !this.state.recIsPressed
    });

    if (this.state.recIsPressed) {

      this.RecMsg = 'Recording!';
      audioRecorderPlayer.addRecordBackListener((e: { current_position: number; }) => {

        this.setState({
          recordSecs: e.current_position,
          recordTime: audioRecorderPlayer.mmssss(
              Math.floor(e.current_position),
          ),
        });
        return;
      });

    } else {

      this.RecMsg = 'Tap to begin recording';
      const result = await audioRecorderPlayer.stopRecorder();

      this.setState({
        recordSecs: 0,
      });

      console.log(result);

    }
  }
  RNFS.readDir(RNFS.CachesDirectoryPath) // On Android, use "RNFS.DocumentDirectoryPath" (MainBundlePath is not defined)
.then((result: any) => {
  if (result.indexOf('m4a')) {
  console.log('GOT RESULT', result);
}
});

const audioContext = AudioContext;

const resp = RNFS.readFileSync('sound.m4a');

const wav = await audioContext.decodeAudioData(resp, (buffer: any) => {
  return toWav(buffer);
  // do something with the WAV ArrayBuffer ...
});

// Spectrogram Visualization Parameters
const targetSampleRate = 44100;
const stftWindowSeconds = 0.015;
const stftHopSeconds = 0.005;
const topDB = 80;

// visualize
const dbSpec = generateSpectrogram(wav); //audio_utils.dBSpectrogram(audioData.waveform, spec_params);
const cropped_imageURI = spectrogram_utils.dBSpectrogramToImage(dbSpec, topDB);
console.log(cropped_imageURI);
function generateSpectrogram(waveform : Float32Array) : Float32Array[]{

  const window_length_samples = Math.round(targetSampleRate * stftWindowSeconds);
  const hop_length_samples = Math.round(targetSampleRate * stftHopSeconds);
  const fft_length = Math.pow(2, Math.ceil(Math.log(window_length_samples) / Math.log(2.0)));

  const spec_params = {
    sampleRate: targetSampleRate,
    hopLength: hop_length_samples,
    winLength: window_length_samples,
    nFft: fft_length,
    topDB
  };

  return audio_utils.dBSpectrogram(waveform, spec_params);

}
z
  onPlayStopPress = async () => {

    this.setState({
      playStopIsPressed: !this.state.playStopIsPressed
    });

    if (this.state.playStopIsPressed) {
      this.PSMsg = 'Playing...';
      console.log('onStartPlay');
      RNFS.readDir(RNFS.CachesDirectoryPath)
          .then((result: any) => {
            if (result.indexOf('m4a')) {
            console.log('File: ', result);
            }
          });

      const msg = await audioRecorderPlayer.startPlayer();
      console.log(msg);
      audioRecorderPlayer.addPlayBackListener((e: { current_position: number; duration: number; }) => {
        if (e.current_position === e.duration) {
          console.log('finished');
          audioRecorderPlayer.stopPlayer();
          audioRecorderPlayer.removePlayBackListener();
          this.setState({
            currentPositionSec: e.current_position,
            currentDurationSec: e.duration,
            playTime: audioRecorderPlayer.mmssss(Math.floor(e.current_position)),
            duration: audioRecorderPlayer.mmssss(Math.floor(e.duration)),
          });
        }
        return;
      });
    } else {
      console.log('onStopPlay');
      audioRecorderPlayer.removePlayBackListener();
      this.PSMsg = 'Play/Stop';
    }
  }
  render() {
    return (
        <View>
          <View style={btnStyles.container}>
            <TouchableOpacity
                style={btnStyles.button}
                onPress={this.onRecPress}>
              <Text>
                {this.RecMsg}
              </Text>
            </TouchableOpacity>
          </View>
          <View style={btnStyles.container}>
            <TouchableOpacity
                style={btnStyles.button}
                onPress={this.onPlayStopPress}>
              <Text>
                {this.PSMsg}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
    );
  }
}


